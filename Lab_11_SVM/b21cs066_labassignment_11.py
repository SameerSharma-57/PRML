# -*- coding: utf-8 -*-
"""B21CS066_LabAssignment_11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AbpNkOsma8vGk3-i4Pln20xN2PAly6fX

#Importing Libraries
"""

!pip install mlxtend --upgrade --no-deps

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import torch
import torchvision
import torchvision.datasets as datasets
from sklearn.model_selection import train_test_split as tts
import torchvision.transforms as transforms
from torch.utils.data import random_split
import torch.nn as nn
import torch.optim as optim
from sklearn.model_selection import  train_test_split as tts
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.svm import SVC
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
from mlxtend.plotting import plot_decision_regions

"""#Problem 1

"""

df=pd.read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/00267/data_banknote_authentication.txt",sep=",",names=['variance','skewness','curtosis','entropy','class'])
df

df.isnull().sum()

X=df.drop('class',axis=1).to_numpy()
y=df['class'].to_numpy()
std_enc=StandardScaler()
X=std_enc.fit_transform(X)

pd.DataFrame(X,columns=df.columns[:-1])

sns.heatmap(df.corr(),annot=True)

X_train,X_temp,y_train,y_temp=tts(X,y,train_size=0.7)
X_test,X_valid,y_test,y_valid=tts(X_temp,y_temp,train_size=2/3)
print(X_train.shape,X_valid.shape,X_test.shape)

def plot_decision_boundary(clf,X,Y):
        # print(n)
        # new_clf_RFC=  BaggingClassifier(base_estimator=SVC(),n_estimators=n ).fit(X_train,Y_train)
        # print(new_clf_RFC.score(X_test,Y_test))
        

        classes=np.unique(Y)
        n_classes = len(classes)
        plot_colors = "rb"
        plot_step = 0.04
        # clf.fit(X,Y)


        # X=self.transform(X)
            
            

        x_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1
        y_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1
        xx, yy = np.meshgrid(np.arange(x_min, x_max, plot_step),
                            np.arange(y_min, y_max, plot_step))
        plt.tight_layout(h_pad=0.5, w_pad=0.5, pad=2.5)

        Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])
        Z = Z.reshape(xx.shape)
        cs = plt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu)

        plt.xlabel("X1")
        plt.ylabel("X2")

        # Plot the training points
        for i, color in zip(range(n_classes), plot_colors):
            idx = np.where(Y == classes[i])
            plt.scatter(X[idx, 0], X[idx, 1], c=color, label=i,
                        cmap=plt.cm.RdYlBu, edgecolor='black', s=16)


        plt.legend(loc='lower right', borderpad=0, handletextpad=0)
        plt.axis("tight")


        plt.show()

for c in [5,10,20,40,100]:
    print('C: ',c)
    clf=SVC(C=c)
    # clf.fit(X_train,y_train)
    X_red=X_train[:,[0,1]]

    clf.fit(X_red,y_train)
    plt.title('C: '+ str(c))
    plot_decision_boundary(clf,X_train[:,[0,1]],y_train)
    # plot_decision_regions(X_train,y_train,clf,feature_index=[1,2],filler_feature_values={0: value, 3:value},filler_feature_ranges={0: width, 3: width})
    plt.show()
    print(clf.score(X_valid[:,[0,1]],y_valid))

for kernel in ['linear', 'poly', 'rbf', 'sigmoid']:
    print('Kernel: ',kernel)
    clf=SVC(kernel=kernel)
    # clf.fit(X_train,y_train)
    X_red=X_train[:,[0,1]]

    clf.fit(X_red,y_train)
    plt.title('kernel: '+ kernel)
    plot_decision_boundary(clf,X_train[:,[0,1]],y_train)
    # plot_decision_regions(X_train,y_train,clf,feature_index=[1,2],filler_feature_values={0: value, 3:value},filler_feature_ranges={0: width, 3: width})
    plt.show()
    print(clf.score(X_valid[:,[0,1]],y_valid))

